package es.weso.rdfshape.server.api.routes.schema.logic.stream.transformations

import cats.effect.IO
import es.weso.rdfshape.server.api.routes.schema.service.operations.stream.SchemaValidateStreamInput
import es.weso.rdfshape.server.api.routes.schema.service.operations.stream.configuration.{
  StreamValidationExtractorConfiguration,
  StreamValidationStreamConfiguration,
  StreamValidationValidatorConfiguration
}
import fs2.Pipe
import org.ragna.comet.exception.stream.timed.StreamTimeoutException
import org.ragna.comet.implicits.RDFElementImplicits._
import org.ragna.comet.stream.extractors.StreamExtractor
import org.ragna.comet.stream.extractors.StreamExtractor.{
  Defaults => ExtractorDefaults
}
import org.ragna.comet.stream.extractors.kafka.KafkaExtractorConfiguration.{
  Defaults => KafkaExtractorDefaults
}
import org.ragna.comet.stream.extractors.kafka.{
  KafkaExtractor,
  KafkaExtractorConfiguration
}
import org.ragna.comet.validation.Validator
import org.ragna.comet.validation.configuration.ValidatorConfiguration
import org.ragna.comet.validation.configuration.ValidatorConfiguration.{
  Defaults => ValidatorDefaults
}
import org.ragna.comet.validation.result.ValidationResult

import scala.concurrent.duration._
import scala.language.postfixOps

/** Object containing additional utilities to get a comet validation
  * stream running from client data
  *
  * @note Some things are taken for granted for this demo/WIP:
  *       - The webserver is meant to receive data from Kafka streams,
  *         thus a [[KafkaExtractor]] will be used
  *       - The incoming Kafka Stream will have its keys ignored and is
  *         expected to transmit RDF data serialized as raw strings
  * @note A timeout is enforced so that the validation stream is
  *       halted when no items are received (even if the client does not disconnect),
  *       thus server resources are not wasted
  */
private[schema] object CometTransformations {

  /** Time that the server will wait without receiving any items for the input
    * stream before raising a [[StreamTimeoutException]]
    */
  private lazy val timeout = 1.5 minutes

  /** Stream transformation pipe:
    * 1. Use the configuration to a stream validation operation as input
    * 2. Build a comet validator/extractor it according the configuration
    * 3. Start the validator, returning its output stream
    *
    * @return A Stream of [[ValidationResult]]s, generated by a comet instance
    *         programmed according to a [[SchemaValidateStreamInput]]
    */
  def toValidationStream
      : Pipe[IO, SchemaValidateStreamInput, ValidationResult] =
    _.flatMap { streamValidationInput =>
      // 0. De-structure the required configurations from client input
      val baseConfig = streamValidationInput.configuration
      // 1. Build comet kafka extractor
      val extractor = mkKafkaExtractor(
        baseConfig.extractorConfiguration,
        baseConfig.streamConfiguration
      )
      // 2. Build comet validator:
      val validator =
        mkStreamValidator(baseConfig.validatorConfiguration, extractor)

      // 3. Initiate the validator, returning its stream
      validator.validate
    }

  /** Given the client's provided extractor and stream configuration, build the
    * equivalent configuration for comet's kafka extractor
    *
    * @param extractorConfiguration Configurations on how to build the extractor,
    *                               received from clients
    * @param streamConfiguration    Configurations on how to find/handle a stream,
    *                               received from clients
    * @return A complying [[KafkaExtractorConfiguration]] usable in streaming
    *         validations
    * @see [[StreamExtractor]]
    */
  private def mkKafkaExtractor(
      extractorConfiguration: StreamValidationExtractorConfiguration,
      streamConfiguration: StreamValidationStreamConfiguration
  ): KafkaExtractor[Unit, String] = {
    val finalConfiguration = KafkaExtractorConfiguration(
      topic = streamConfiguration.topic,
      server = streamConfiguration.server,
      port = streamConfiguration.port.getOrElse(
        KafkaExtractorDefaults.defaultServerPort
      ),
      groupId = streamConfiguration.groupId.getOrElse(
        KafkaExtractorDefaults.defaultConsumerGroupId
      )
    )

    KafkaExtractor[Unit, String](
      configuration = finalConfiguration,
      format = extractorConfiguration.cometDataFormat,
      inference = extractorConfiguration.dataInference.getOrElse(
        ExtractorDefaults.defaultInferenceEngine
      ),
      concurrentItems = extractorConfiguration.concurrentItems.getOrElse(
        ExtractorDefaults.defaultConcurrentParsing
      ),
      itemTimeout = Some(timeout)
    )
  }

  /** Given the client's provided validator configuration and an extractor,
    * build a stream validator
    *
    * @param validatorConfiguration Configurations on how the validator should work,
    *                               received from clients
    * @param extractor              The extractor from which this validator will pull its data
    * @tparam A Type of the items that the underlying extractor is expected to
    *           receive (for this demo, these items will be Strings)
    * @return A comet Validator pre-configured to get data from an extractor
    *         and start emitting validation results
    */
  private def mkStreamValidator[A](
      validatorConfiguration: StreamValidationValidatorConfiguration,
      extractor: StreamExtractor[A]
  ): Validator[A] = {
    val finalConfiguration = ValidatorConfiguration(
      schema = validatorConfiguration.schema,
      trigger = validatorConfiguration.trigger,
      haltOnInvalid = validatorConfiguration.haltOnInvalid.getOrElse(
        ValidatorDefaults.defaultHaltOnInvalid
      ),
      haltOnErrored = validatorConfiguration.haltOnErrored.getOrElse(
        ValidatorDefaults.defaultHaltOnErrored
      ),
      concurrentItems = validatorConfiguration.concurrentItems.getOrElse(
        ValidatorDefaults.defaultConcurrentValidations
      )
    )

    new Validator(finalConfiguration, extractor)
  }

}
